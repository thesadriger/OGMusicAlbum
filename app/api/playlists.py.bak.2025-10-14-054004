from __future__ import annotations

import os, re, hmac, json, uuid, time, base64, hashlib, urllib.parse
from typing import Optional

import asyncpg
from pydantic import BaseModel
from fastapi import (
    APIRouter, Depends, HTTPException, Query, Body, Header, Request, Cookie, status
)

from app.api.users import _get_pool  # пул подключений

router = APIRouter()

JWT_SECRET = os.environ.get("API_JWT_SECRET") or ""
BOT_TOKEN  = os.environ.get("TELEGRAM_BOT_TOKEN") or os.environ.get("BOT_TOKEN") or ""

HANDLE_RE = re.compile(r"^[a-z0-9_]{3,32}$")

def _clean_handle(s: Optional[str]) -> Optional[str]:
    if not s: return None
    s = s.strip().lstrip("@").lower()
    return s or None

# --- мини-JWT (HS256) ---
def _b64url_decode(data: str) -> bytes:
    pad = "=" * (-len(data) % 4)
    return base64.urlsafe_b64decode(data + pad)

def _b64url_encode(b: bytes) -> str:
    return base64.urlsafe_b64encode(b).rstrip(b"=").decode()

def _parse_jwt_hs256(token: str, secret: str) -> Optional[dict]:
    try:
        h_b64, p_b64, s_b64 = token.split(".")
    except ValueError:
        return None
    try:
        header = json.loads(_b64url_decode(h_b64))
        payload = json.loads(_b64url_decode(p_b64))
    except Exception:
        return None
    if not isinstance(header, dict) or header.get("alg") != "HS256":
        return None
    mac = hmac.new(secret.encode(), msg=f"{h_b64}.{p_b64}".encode(), digestmod=hashlib.sha256).digest()
    if not hmac.compare_digest(_b64url_encode(mac), s_b64):
        return None
    exp = payload.get("exp")
    if isinstance(exp, (int, float)) and time.time() > float(exp):
        return None
    return payload

# --- Telegram WebApp initData verification ---
def _tg_init_secret(bot_token: str) -> bytes:
    return hmac.new(b"WebAppData", bot_token.encode(), hashlib.sha256).digest()

def _verify_tg_initdata(raw: str, bot_token: str) -> Optional[dict]:
    if not bot_token:
        return None
    params = urllib.parse.parse_qs(raw, keep_blank_values=True, strict_parsing=False)
    params = {k: v[-1] for k, v in params.items()}
    given_hash = params.pop("hash", None)
    if not given_hash:
        return None
    data_check_string = "\n".join(f"{k}={params[k]}" for k in sorted(params.keys()))
    secret = _tg_init_secret(bot_token)
    mac = hmac.new(secret, msg=data_check_string.encode(), digestmod=hashlib.sha256).hexdigest()
    if not hmac.compare_digest(mac, given_hash):
        return None
    auth_date = params.get("auth_date")
    if auth_date and auth_date.isdigit():
        ts = int(auth_date)
        if ts < time.time() - 24 * 3600:
            return None
    try:
        user = json.loads(params.get("user", "{}"))
    except Exception:
        user = {}
    if not isinstance(user, dict):
        user = {}
    return {
        "user": user,
        "auth_date": int(params.get("auth_date", "0") or 0),
        "query_id": params.get("query_id"),
    }

# ----------------- МОДЕЛИ -----------------
class PlaylistCreate(BaseModel):
    title: str
    is_public: bool = False
    handle: Optional[str] = None

class HandleUpdate(BaseModel):
    handle: Optional[str] = None

class RemoveItemBody(BaseModel):
    track_id: Optional[str] = None
    msg_id: Optional[int] = None
    chat: Optional[str] = None

# ----------------- AUTH -----------------
async def _ensure_db_user(con: asyncpg.Connection, uid: int) -> None:
    await con.execute(
        "INSERT INTO users (telegram_id) VALUES ($1) ON CONFLICT (telegram_id) DO NOTHING",
        uid,
    )

async def _ensure_default_playlist(con: asyncpg.Connection, user_id: int) -> str:
    row = await con.fetchrow(
        """
        INSERT INTO playlists (user_id, title, kind)
        VALUES ($1, 'Мой плейлист', 'custom')
        ON CONFLICT (user_id, title) DO UPDATE SET title = EXCLUDED.title
        RETURNING id::text
        """,
        user_id,
    )
    return row["id"]

async def get_current_user(
    request: Request,
    pool: asyncpg.Pool = Depends(_get_pool),
    x_user_id: Optional[int] = Header(default=None, alias="X-User-Id"),
    authorization: Optional[str] = Header(default=None, alias="Authorization"),
    x_tg_init: Optional[str] = Header(default=None, alias="X-Telegram-Init-Data"),
    init_qs: Optional[str] = Query(default=None, alias="init"),
    ogma_session: Optional[str] = Cookie(default=None, alias="ogma_session"),
) -> int:
    uid: Optional[int] = None

    if x_user_id:
        try:
            uid = int(x_user_id)
        except Exception:
            raise HTTPException(401, "Bad X-User-Id")

    if uid is None and authorization and authorization.lower().startswith("bearer "):
        token = authorization.split(None, 1)[1].strip()
        if JWT_SECRET:
            payload = _parse_jwt_hs256(token, JWT_SECRET)
            if payload:
                cand = payload.get("uid") or payload.get("sub")
                if isinstance(cand, int) or (isinstance(cand, str) and cand.isdigit()):
                    uid = int(cand)

    if uid is None and ogma_session and JWT_SECRET:
        payload = _parse_jwt_hs256(ogma_session, JWT_SECRET)
        if payload:
            cand = payload.get("uid") or payload.get("sub")
            if isinstance(cand, int) or (isinstance(cand, str) and cand.isdigit()):
                uid = int(cand)

    if uid is None and (x_tg_init or init_qs):
        raw = x_tg_init or init_qs or ""
        v = _verify_tg_initdata(raw, BOT_TOKEN)
        if v and isinstance(v.get("user"), dict):
            tg_user = v["user"]
            cand = tg_user.get("id")
            if isinstance(cand, int) or (isinstance(cand, str) and str(cand).isdigit()):
                uid = int(cand)

    if uid is None:
        raise HTTPException(401, "Unauthorized")

    async with pool.acquire() as con:
        await _ensure_db_user(con, uid)
        await _ensure_default_playlist(con, uid)

    return uid

# ----------------- HELPERS -----------------
async def _delete_item_by_track(con: asyncpg.Connection, pid: uuid.UUID, tid: uuid.UUID) -> int:
    tag = await con.execute(
        "DELETE FROM playlist_items WHERE playlist_id=$1 AND track_id=$2",
        pid, tid
    )
    try:
        return int(tag.split()[-1])  # "DELETE 1" → 1
    except Exception:
        return 0

async def _delete_item_by_msg(con: asyncpg.Connection, pid: uuid.UUID, msg_id: int, chat: str) -> int:
    chat = chat.lstrip("@")
    tag = await con.execute(
        """
        DELETE FROM playlist_items i
        USING tracks t
        WHERE i.playlist_id = $1
          AND i.track_id = t.id
          AND t.tg_msg_id = $2
          AND lower(t.chat_username) = lower($3)
        """,
        pid, msg_id, chat
    )
    try:
        return int(tag.split()[-1])
    except Exception:
        return 0

# ----------------- РУЧКИ (короткая выжимка нужного) -----------------

@router.get("/playlists/by-handle/{handle}")
async def get_public_playlist_by_handle(
    handle: str,
    pool: asyncpg.Pool = Depends(_get_pool),
):
    h = _clean_handle(handle)
    if not h or not HANDLE_RE.fullmatch(h):
        raise HTTPException(400, "Invalid handle format")
    async with pool.acquire() as con:
        row = await con.fetchrow(
            """
            SELECT id::text, user_id, title, kind, is_public, handle, created_at, updated_at
            FROM playlists
            WHERE is_public = true AND lower(handle)=lower($1)
            """,
            h,
        )
    if not row:
        raise HTTPException(404, "Playlist not found")
    return dict(row)

@router.get("/playlists/by-handle/{handle}/items")
async def get_public_playlist_items_by_handle(
    handle: str,
    limit: int = Query(50, ge=1, le=200),
    offset: int = Query(0, ge=0),
    pool: asyncpg.Pool = Depends(_get_pool),
):
    h = _clean_handle(handle)
    if not h or not HANDLE_RE.fullmatch(h):
        raise HTTPException(400, "Invalid handle")
    async with pool.acquire() as con:
        pid = await con.fetchval(
            "SELECT id FROM playlists WHERE is_public=true AND lower(handle)=lower($1)",
            h,
        )
        if not pid:
            raise HTTPException(404, "Playlist not found")

        rows = await con.fetch(
            """
            SELECT
              t.id::text AS id,
              t.tg_msg_id AS "msgId",
              t.chat_username AS chat,
              t.title, t.artists, t.hashtags,
              t.duration_s AS duration,
              t.mime, t.size_bytes, t.created_at,
              i.position, i.added_at
            FROM playlist_items i
            JOIN tracks t ON t.id = i.track_id
            WHERE i.playlist_id = $1
            ORDER BY i.position
            LIMIT $2 OFFSET $3
            """,
            pid, limit, offset,
        )
        total = await con.fetchval(
            "SELECT COUNT(*) FROM playlist_items WHERE playlist_id=$1", pid
        )
    return {"items": [dict(r) for r in rows], "limit": limit, "offset": offset, "total": total}

# ---------- УДАЛЕНИЕ ИЗ ПУБЛИЧНОГО ПЛЕЙЛИСТА ПО HANDLE ----------
# (удаляем СВЯЗЬ из playlist_items; источник OGMA_archive не трогаем)

@router.delete("/playlists/by-handle/{handle}/items/{track_id}")
async def remove_item_public_by_track_path(
    handle: str,
    track_id: str,
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    h = _clean_handle(handle)
    if not h or not HANDLE_RE.fullmatch(h):
        raise HTTPException(400, "Invalid handle format")
    try:
        tid = uuid.UUID(track_id)
    except Exception:
        raise HTTPException(400, "Invalid UUID")

    async with pool.acquire() as con:
        row = await con.fetchrow(
            "SELECT id, user_id FROM playlists WHERE is_public=true AND lower(handle)=lower($1)",
            h,
        )
        if not row:
            raise HTTPException(404, "Playlist not found")
        pid, owner = row["id"], row["user_id"]
        if owner != user_id:
            raise HTTPException(403, "Forbidden")

        n = await _delete_item_by_track(con, pid, tid)
        if n == 0:
            raise HTTPException(404, "Item not found")
    return {"ok": True}

@router.delete("/playlists/by-handle/{handle}/items/by-msg/{msg_id}")
async def remove_item_public_by_msg_path(
    handle: str,
    msg_id: int,
    chat: str = Query(...),
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    h = _clean_handle(handle)
    if not h or not HANDLE_RE.fullmatch(h):
        raise HTTPException(400, "Invalid handle format")

    async with pool.acquire() as con:
        row = await con.fetchrow(
            "SELECT id, user_id FROM playlists WHERE is_public=true AND lower(handle)=lower($1)",
            h,
        )
        if not row:
            raise HTTPException(404, "Playlist not found")
        pid, owner = row["id"], row["user_id"]
        if owner != user_id:
            raise HTTPException(403, "Forbidden")

        n = await _delete_item_by_msg(con, pid, msg_id, chat)
        if n == 0:
            raise HTTPException(404, "Item not found")
    return {"ok": True}

@router.delete("/playlists/by-handle/{handle}/items")
async def remove_item_public_by_query(
    handle: str,
    track_id: Optional[str] = Query(None),
    msg_id: Optional[int] = Query(None),
    chat: Optional[str] = Query(None),
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    if not track_id and not (msg_id and chat):
        raise HTTPException(422, "Provide track_id OR (msg_id AND chat)")
    if track_id:
        return await remove_item_public_by_track_path(handle, track_id, pool, user_id)
    else:
        return await remove_item_public_by_msg_path(handle, int(msg_id), chat or "", pool, user_id)

@router.post("/playlists/by-handle/{handle}/items")
async def remove_item_public_by_handle_override(
    handle: str,
    track_id: Optional[str] = Query(None),
    msg_id: Optional[int] = Query(None),
    chat: Optional[str] = Query(None),
    x_method_override: Optional[str] = Header(default=None, alias="X-HTTP-Method-Override"),
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    # POST + X-HTTP-Method-Override: DELETE — поддержим оба варианта (track_id ИЛИ msg_id+chat)
    if (x_method_override or "").strip().upper() == "DELETE":
        if track_id:
            return await remove_item_public_by_track_path(handle, track_id, pool, user_id)
        if msg_id is not None and chat:
            return await remove_item_public_by_msg_path(handle, int(msg_id), chat, pool, user_id)
        raise HTTPException(422, "Provide track_id OR (msg_id AND chat)")
    raise HTTPException(405, "Method Not Allowed")

@router.post("/playlists/by-handle/{handle}/items/remove")
async def remove_item_public_by_post(
    handle: str,
    body: RemoveItemBody,
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    if body.track_id:
        return await remove_item_public_by_track_path(handle, body.track_id, pool, user_id)
    if body.msg_id is not None and body.chat:
        return await remove_item_public_by_msg_path(handle, int(body.msg_id), body.chat, pool, user_id)
    raise HTTPException(422, "Provide track_id OR (msg_id AND chat)")
