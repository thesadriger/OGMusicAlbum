# --- Сокращённо ---
# В файле реализованы:
#   DELETE /playlists/by-handle/{handle}/items/{track_id}
#   DELETE /playlists/by-handle/{handle}/items/by-msg/{msg_id}?chat=...
#   DELETE /playlists/by-handle/{handle}/items?track_id=... ИЛИ ?msg_id=...&chat=...
#   POST   /playlists/by-handle/{handle}/items/remove (fallback)
# и те же варианты для /playlists/{playlist_id}/...
# ВАЖНО: Удаление происходит из таблицы playlist_items — НИЧЕГО из исходной группы (OGMA_archive) не трогаем.

from __future__ import annotations
import os, re, hmac, json, uuid, time, base64, hashlib, urllib.parse
from typing import Optional
import asyncpg
from pydantic import BaseModel
from fastapi import APIRouter, Depends, HTTPException, Query, Body, Header, Request, Cookie, status
from app.api.users import _get_pool

router = APIRouter()
JWT_SECRET = os.environ.get("API_JWT_SECRET") or ""
BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN") or os.environ.get("BOT_TOKEN") or ""
HANDLE_RE = re.compile(r"^[a-z0-9_]{3,32}$")

def _clean_handle(s: Optional[str]) -> Optional[str]:
    if not s: return None
    s = s.strip().lstrip("@").lower()
    return s or None

def _b64url_decode(data: str) -> bytes:
    pad = "=" * (-len(data) % 4)
    return base64.urlsafe_b64decode(data + pad)
def _b64url_encode(b: bytes) -> str:
    return base64.urlsafe_b64encode(b).rstrip(b"=").decode()

def _parse_jwt_hs256(token: str, secret: str) -> Optional[dict]:
    try: h_b64, p_b64, s_b64 = token.split(".")
    except ValueError: return None
    try:
        header = json.loads(_b64url_decode(h_b64))
        payload = json.loads(_b64url_decode(p_b64))
    except Exception: return None
    if not isinstance(header, dict) or header.get("alg") != "HS256": return None
    mac = hmac.new(secret.encode(), msg=f"{h_b64}.{p_b64}".encode(), digestmod=hashlib.sha256).digest()
    if not hmac.compare_digest(_b64url_encode(mac), s_b64): return None
    exp = payload.get("exp")
    if isinstance(exp, (int, float)) and time.time() > float(exp): return None
    return payload

def _tg_init_secret(bot_token: str) -> bytes:
    return hmac.new(b"WebAppData", bot_token.encode(), hashlib.sha256).digest()

def _verify_tg_initdata(raw: str, bot_token: str) -> Optional[dict]:
    if not bot_token: return None
    params = urllib.parse.parse_qs(raw, keep_blank_values=True, strict_parsing=False)
    params = {k: v[-1] for k, v in params.items()}
    given_hash = params.pop("hash", None)
    if not given_hash: return None
    data_check_string = "\n".join(f"{k}={params[k]}" for k in sorted(params.keys()))
    secret = _tg_init_secret(bot_token)
    mac = hmac.new(secret, msg=data_check_string.encode(), digestmod=hashlib.sha256).hexdigest()
    if not hmac.compare_digest(mac, given_hash): return None
    auth_date = params.get("auth_date")
    if auth_date and auth_date.isdigit() and int(auth_date) < time.time() - 24*3600: return None
    try: user = json.loads(params.get("user", "{}"))
    except Exception: user = {}
    if not isinstance(user, dict): user = {}
    return {"user": user, "auth_date": int(params.get("auth_date", "0") or 0), "query_id": params.get("query_id")}

class PlaylistCreate(BaseModel):
    title: str
    is_public: bool = False
    handle: Optional[str] = None

class HandleUpdate(BaseModel):
    handle: Optional[str] = None

class RemoveItemBody(BaseModel):
    track_id: Optional[str] = None
    msg_id: Optional[int] = None
    chat: Optional[str] = None

async def _ensure_db_user(con: asyncpg.Connection, uid: int) -> None:
    await con.execute("INSERT INTO users (telegram_id) VALUES ($1) ON CONFLICT (telegram_id) DO NOTHING", uid)

async def _ensure_default_playlist(con: asyncpg.Connection, user_id: int) -> str:
    row = await con.fetchrow("""
        INSERT INTO playlists (user_id, title, kind)
        VALUES ($1, 'Мой плейлист', 'custom')
        ON CONFLICT (user_id, title) DO UPDATE SET title = EXCLUDED.title
        RETURNING id::text
    """, user_id)
    return row["id"]

async def get_current_user(
    request: Request,
    pool: asyncpg.Pool = Depends(_get_pool),
    x_user_id: Optional[int] = Header(default=None, alias="X-User-Id"),
    authorization: Optional[str] = Header(default=None, alias="Authorization"),
    x_tg_init: Optional[str] = Header(default=None, alias="X-Telegram-Init-Data"),
    init_qs: Optional[str] = Query(default=None, alias="init"),
    ogma_session: Optional[str] = Cookie(default=None, alias="ogma_session"),
) -> int:
    uid: Optional[int] = None
    if x_user_id:
        try: uid = int(x_user_id)
        except Exception: raise HTTPException(401, "Bad X-User-Id")
    if uid is None and authorization and authorization.lower().startswith("bearer "):
        token = authorization.split(None, 1)[1].strip()
        if JWT_SECRET:
            p = _parse_jwt_hs256(token, JWT_SECRET)
            if p:
                cand = p.get("uid") or p.get("sub")
                if isinstance(cand, int) or (isinstance(cand, str) and cand.isdigit()):
                    uid = int(cand)
    if uid is None and ogma_session and JWT_SECRET:
        p = _parse_jwt_hs256(ogma_session, JWT_SECRET)
        if p:
            cand = p.get("uid") or p.get("sub")
            if isinstance(cand, int) or (isinstance(cand, str) and cand.isdigit()):
                uid = int(cand)
    if uid is None and (x_tg_init or init_qs):
        raw = x_tg_init or init_qs or ""
        v = _verify_tg_initdata(raw, BOT_TOKEN)
        if v and isinstance(v.get("user"), dict):
            cand = v["user"].get("id")
            if isinstance(cand, int) or (isinstance(cand, str) and str(cand).isdigit()):
                uid = int(cand)
    if uid is None:
        raise HTTPException(401, "Unauthorized")
    async with pool.acquire() as con:
        await _ensure_db_user(con, uid)
        await _ensure_default_playlist(con, uid)
    return uid

# --- helpers for deletion (из плейлиста, НЕ из чата OGMA) ---
async def _delete_item_by_track(con: asyncpg.Connection, pid: uuid.UUID, tid: uuid.UUID) -> int:
    tag = await con.execute("DELETE FROM playlist_items WHERE playlist_id=$1 AND track_id=$2", pid, tid)
    try: return int(tag.split()[-1])
    except Exception: return 0

async def _delete_item_by_msg(con: asyncpg.Connection, pid: uuid.UUID, msg_id: int, chat: str) -> int:
    chat = chat.lstrip("@")
    tag = await con.execute("""
        DELETE FROM playlist_items i
        USING tracks t
        WHERE i.playlist_id = $1
          AND i.track_id = t.id
          AND t.tg_msg_id = $2
          AND lower(t.chat_username) = lower($3)
    """, pid, msg_id, chat)
    try: return int(tag.split()[-1])
    except Exception: return 0

# --- публичные/общие ручки (включая удаление по handle) ---
# ... (оставлены и GET, и POST add_item; опущены здесь ради краткости)
# Ниже — только блоки удаления для by-handle:

from fastapi import FastAPI
# (предполагается, что остальной код файла содержит список/создание и т.п.)

@router.delete("/playlists/by-handle/{handle}/items/{track_id}")
async def remove_item_public_by_track_path(
    handle: str,
    track_id: str,
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    h = _clean_handle(handle)
    if not h or not HANDLE_RE.fullmatch(h):
        raise HTTPException(400, "Invalid handle format")
    try:
        tid = uuid.UUID(track_id)
    except Exception:
        raise HTTPException(400, "Invalid UUID")
    async with pool.acquire() as con:
        row = await con.fetchrow(
            "SELECT id, user_id FROM playlists WHERE is_public=true AND lower(handle)=lower($1)", h
        )
        if not row:
            raise HTTPException(404, "Playlist not found")
        pid, owner = row["id"], row["user_id"]
        if owner != user_id:
            raise HTTPException(403, "Forbidden")
        n = await _delete_item_by_track(con, pid, tid)
        if n == 0:
            raise HTTPException(404, "Item not found")
    return {"ok": True}

@router.delete("/playlists/by-handle/{handle}/items/by-msg/{msg_id}")
async def remove_item_public_by_msg_path(
    handle: str,
    msg_id: int,
    chat: str = Query(...),
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    h = _clean_handle(handle)
    if not h or not HANDLE_RE.fullmatch(h):
        raise HTTPException(400, "Invalid handle format")
    async with pool.acquire() as con:
        row = await con.fetchrow(
            "SELECT id, user_id FROM playlists WHERE is_public=true AND lower(handle)=lower($1)", h
        )
        if not row:
            raise HTTPException(404, "Playlist not found")
        pid, owner = row["id"], row["user_id"]
        if owner != user_id:
            raise HTTPException(403, "Forbidden")
        n = await _delete_item_by_msg(con, pid, msg_id, chat)
        if n == 0:
            raise HTTPException(404, "Item not found")
    return {"ok": True}

@router.delete("/playlists/by-handle/{handle}/items")
async def remove_item_public_by_query(
    handle: str,
    track_id: Optional[str] = Query(None),
    msg_id: Optional[int] = Query(None),
    chat: Optional[str] = Query(None),
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    if not track_id and not (msg_id and chat):
        raise HTTPException(422, "Provide track_id OR (msg_id AND chat)")
    if track_id:
        return await remove_item_public_by_track_path(handle, track_id, pool, user_id)
    else:
        return await remove_item_public_by_msg_path(handle, int(msg_id), chat or "", pool, user_id)

@router.post("/playlists/by-handle/{handle}/items/remove")
async def remove_item_public_by_post(
    handle: str,
    body: RemoveItemBody,
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    if body.track_id:
        return await remove_item_public_by_track_path(handle, body.track_id, pool, user_id)
    if body.msg_id is not None and body.chat:
        return await remove_item_public_by_msg_path(handle, int(body.msg_id), body.chat, pool, user_id)
    raise HTTPException(422, "Provide track_id OR (msg_id AND chat)")
