import { useEffect, useRef, useState, useCallback, useMemo } from "react";
import { apiGet, ApiError } from "@/lib/api";
import type { Track } from "@/types/types";
import { TrackCard } from "./components/TrackCard";
import UserAvatar from "@/components/UserAvatar";
import { AuthGate } from "@/components/AuthGate";
import ArtistPage from "@/pages/ArtistPage";
import {
  useHashRoute,
  goArtist,
  goBackSmart,
  Route,
  goPlaylist,
} from "@/lib/router";
import { pushRecentArtists } from "@/lib/recent";
import ArtistsListPage from "@/pages/ArtistsListPage";
import PlaylistPage from "@/pages/PlaylistPage";
import GlobalAudioPlayer from "@/components/GlobalAudioPlayer";
import ProfilePage from "@/pages/Profile";
import PublicPlaylistPage from "@/pages/PublicPlaylistPage";
import { useMe } from "@/hooks/useMe";
import TracksCarousel from "@/components/TracksCarousel";
import AddToPlaylistPopover from "@/components/AddToPlaylistPopover";

type SearchResp = { hits: Track[]; total?: number };
type RecsResp = { items: Track[]; limit: number };

// универсальный ответ бэка (/api/search)
type UniversalSearchResp = {
  query: string;
  term: string;
  tracks?: Track[];
  users?: any[];
  playlists?: any[];
  total?: number;
};

// на всякий случай — «каталожный» формát, если вернётся items[]
type MaybeCatalogResp = { items?: Track[]; total?: number };

// === Add-to-Playlist popover ===
type PlaylistLite = { id: string; title: string; handle?: string | null; is_public?: boolean };
const addBtnAnchorRef = useRef<HTMLElement>(null);
const [addOpen, setAddOpen] = useState(false);
const [addTrack, setAddTrack] = useState<Track | null>(null);
const [publicPlaylists, setPublicPlaylists] = useState<PlaylistLite[]>([]);
const [containsMap, setContainsMap] = useState<Record<string, boolean>>({});
const [addDisabled, setAddDisabled] = useState(false);

// безопасно ищем «+»-кнопку плеера как якорь (одна на странице)
const resolveAddAnchor = useCallback(() => {
  const el = document.querySelector(
    'button[aria-label="Добавить трек в плейлист"]'
  ) as HTMLElement | null;
  if (el) addBtnAnchorRef.current = el;
}, []);

const openAddPopover = useCallback(async (track: Track) => {
  setAddTrack(track);
  resolveAddAnchor();
  setAddOpen(true);

  // подгружаем публичные плейлисты лениво (мягкий фоллбек)
  try {
    const r = await apiGet<{ items?: PlaylistLite[] }>("/me/public-playlists?limit=50", {
      timeoutMs: 15000,
    }).catch(() => ({ items: [] as PlaylistLite[] }));
    setPublicPlaylists(r?.items || []);
    // если есть эндпоинт проверки вхождения — можно дернуть тут; пока пустая карта
    setContainsMap({});
  } catch {
    setPublicPlaylists([]);
    setContainsMap({});
  }
}, []);

function RecSection({
  recs,
  nowId,
  paused,
  onToggle,
}: {
  recs: Track[];
  nowId: string | null;
  paused: boolean;
  onToggle: (list: Track[], startIndex: number) => void;
}) {

  const [open, setOpen] = useState(false);
  const top = recs.slice(0, 3);
  const rest = recs.slice(3, 20);
  const all = [...top, ...rest];

  const CTA_BTN =
    "appearance-none select-none w-full h-12 flex items-center justify-center px-4 " +
    "text-base leading-none font-medium tracking-wide " +
    "bg-zinc-200/90 dark:bg-zinc-800/90 text-zinc-900 dark:text-zinc-50 " +
    "hover:opacity-95 active:opacity-90";

  return (
    <section className="relative rounded-2xl border border-zinc-200 dark:border-zinc-800 bg-white/70 dark:bg-zinc-900/60 p-3 overflow-hidden shadow">
      <div className="flex items-center justify-between px-1">
        <div className="text-sm text-zinc-500">Рекомендации</div>
        {open && (
          <button
            onClick={() => setOpen(false)}
            className="px-3 py-1 rounded-lg text-xs bg-zinc-200 dark:bg-zinc-800 text-zinc-900 dark:text-zinc-100 hover:opacity-90 active:opacity-80"
          >
            свернуть
          </button>
        )}
      </div>

      <div className="mt-3 space-y-3">
        {top.map((t, i) => (
          <TrackCard
            key={t.id}
            t={t}
            isActive={nowId === t.id}
            isPaused={paused}
            onToggle={() => onToggle(all, i)}
          />
        ))}
      </div>

      {!open && (
        <div className="pointer-events-none absolute inset-x-0 bottom-0 -mx-3 -mb-3 z-10 rounded-b-2xl overflow-hidden">
          <div className="bg-gradient-to-b from-transparent via-white/70 to-white dark:via-zinc-900/50 dark:to-zinc-900 shadow-[0_-18px_32px_rgba(0,0,0,0.65)]">
            <button
              onClick={() => setOpen(true)}
              className={`${CTA_BTN} rounded-b-2xl pointer-events-auto`}
            />
          </div>
        </div>
      )}

      {open && (
        <div className="mt-3 space-y-3">
          {rest.map((t, j) => (
            <TrackCard
              key={t.id}
              t={t}
              isActive={nowId === t.id}
              isPaused={paused}
              onToggle={() => onToggle(all, 3 + j)}
            />
          ))}
          <div className="mt-3 -mx-3 -mb-3">
            <button onClick={() => setOpen(false)} className={`${CTA_BTN} rounded-b-2xl`}>
              Скрыть рекомендации
            </button>
          </div>
        </div>
      )}
    </section>
  );
}

export default function App() {
  const route: Route = useHashRoute();

  // имя пользователя как в профиле
  const { me } = useMe();
  const rawName = (me?.name || me?.username || "").trim();
  const ownerLabel = (rawName.split(/\s+/)[0] || "").trim();
  const playlistTitle = ownerLabel ? `${ownerLabel} MusicAlbum` : "MusicAlbum";

  const [q, setQ] = useState("");
  const inputRef = useRef<HTMLInputElement | null>(null);
  const [items, setItems] = useState<Track[]>([]);
  const [total, setTotal] = useState<number | null>(null);
  const [recs, setRecs] = useState<Track[]>([]);
  const recsShuffled = useMemo(() => {
    const a = [...recs];
    // Фишер-Йетс, чтобы рандом был честный и стабильный в пределах ответа
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }, [recs]);
  const [now, setNow] = useState<Track | null>(null);
  const [loading, setLoading] = useState(false);
  const [paused, setPaused] = useState(false);

  const [queue, setQueue] = useState<Track[]>([]);
  const [qIndex, setQIndex] = useState<number>(-1);

  // режим перемешивания для текущей очереди
  const [shuffle, setShuffle] = useState(false);

  const playList = (list: Track[], startIndex: number) => {
    const safe = list.filter(Boolean);
    if (!safe.length) return;
    const idx = Math.max(0, Math.min(startIndex, safe.length - 1));
    setQueue(safe);
    setQIndex(idx);
    setNow(safe[idx]);
    setPaused(false);
    pushRecentArtists(safe[idx].artists ?? []);
  };

  const toggleTrack = (list: Track[], index: number, trackId: string) => {
    if (now && now.id === trackId) {
      const wasPaused = paused;
      setPaused((p) => !p);
      if (wasPaused && now && window.__ogmaPlay) {
        try {
          window.__ogmaPlay(now);
        } catch { }
      }
      return;
    }
    const t = list[index];
    if (!t) return;
    setNow(t);
    setPaused(false);
    try {
      window.__ogmaPlay?.(t);
    } catch { }
    setQueue(list.filter(Boolean));
    setQIndex(index);
    pushRecentArtists(t.artists ?? []);
  };

  const onQueueEnd = () => {
    setPaused(true);
  };

  const next = useCallback((wrap: boolean = false): boolean => {
    if (!queue.length) return false;

    // если включён shuffle — выбираем случайный индекс (не равный текущему)
    if (shuffle && queue.length > 1) {
      const len = queue.length;
      let nextIdx = qIndex;
      do {
        nextIdx = Math.floor(Math.random() * len);
      } while (nextIdx === qIndex);

      const tr = queue[nextIdx];
      if (!tr) return false;

      setQIndex(nextIdx);
      setNow(tr);
      try { (window as any).__ogmaPlay?.(tr); } catch { }
      setPaused(false);
      try { pushRecentArtists(tr.artists ?? []); } catch { }
      return true;
    }

    // обычный последовательный режим
    let moved = false;
    setQIndex((prev) => {
      if (prev < 0) return prev;
      const safeLen = queue.length;
      let nextIdx = prev + 1;

      if (nextIdx >= safeLen) {
        if (!wrap) {
          onQueueEnd?.();
          return prev;
        }
        nextIdx = 0;
      }

      const tr = queue[nextIdx];
      if (!tr) return prev;

      setNow(tr);
      try { (window as any).__ogmaPlay?.(tr); } catch { }
      setPaused(false);
      try { pushRecentArtists(tr.artists ?? []); } catch { }

      moved = true;
      return nextIdx;
    });

    return moved;
  }, [queue, shuffle, qIndex]);

  const prev = useCallback((wrap: boolean = false): boolean => {
    if (!queue.length) return false;

    if (shuffle && queue.length > 1) {
      const len = queue.length;
      let nextIdx = qIndex;
      do {
        nextIdx = Math.floor(Math.random() * len);
      } while (nextIdx === qIndex);

      const tr = queue[nextIdx];
      if (!tr) return false;

      setQIndex(nextIdx);
      setNow(tr);
      try { (window as any).__ogmaPlay?.(tr); } catch { }
      setPaused(false);
      try { pushRecentArtists(tr.artists ?? []); } catch { }
      return true;
    }

    let moved = false;
    setQIndex((prevIdx) => {
      if (prevIdx < 0) return prevIdx;

      const safeLen = queue.length;
      let nextIdx = prevIdx - 1;

      if (nextIdx < 0) {
        if (!wrap) return prevIdx;
        nextIdx = Math.max(0, safeLen - 1);
      }

      const tr = queue[nextIdx];
      if (!tr) return prevIdx;

      setNow(tr);
      try { (window as any).__ogmaPlay?.(tr); } catch { }
      setPaused(false);
      try { pushRecentArtists(tr.artists ?? []); } catch { }

      moved = true;
      return nextIdx;
    });

    return moved;
  }, [queue, shuffle, qIndex]);

  useEffect(() => {
    (window as any).__ogmaPlayList = (list: Track[], startIndex: number) => {
      playList(list, startIndex);
      requestAnimationFrame(() => {
        try {
          (window as any).__ogmaPlay?.(list[startIndex]);
        } catch { }
      });
    };
    return () => {
      delete (window as any).__ogmaPlayList;
    };
  }, []);

  useEffect(() => {
    try {
      window?.Telegram?.WebApp?.ready?.();
      window?.Telegram?.WebApp?.expand?.();
    } catch { }
  }, []);

  useEffect(() => {
    let cancelled = false;
    setLoading(true);
    apiGet<RecsResp>("/me/recs?limit=20", { timeoutMs: 20000 })
      .then((r) => {
        if (!cancelled) setRecs(r.items ?? []);
      })
      .catch(() => {
        if (!cancelled) setRecs([]);
      })
      .finally(() => {
        if (!cancelled) setLoading(false);
      });
    return () => {
      cancelled = true;
    };
  }, []);

  useEffect(() => {
    const s = q.trim();
    if (!s) {
      setItems([]);
      setTotal(null);
      return;
    }

    let cancelled = false;
    const timer = setTimeout(() => {
      (async () => {
        setLoading(true);

        // важно: API ограничивает limit <= 50, иначе 422
        const PAGE = 50;
        const MAX_PAGES = 20;

        let offset = 0;
        const acc: Track[] = [];
        let totalValue: number | null = null;

        for (let i = 0; i < MAX_PAGES; i++) {
          const params = new URLSearchParams({
            q: s,
            limit: String(PAGE),
            offset: String(offset),
          });

          // поддерживаем сразу несколько форматов ответа
          let resp: SearchResp | UniversalSearchResp | MaybeCatalogResp;

          try {
            // универсальный эндпоинт
            resp = await apiGet(`/search?${params.toString()}`, { timeoutMs: 20000 });
          } catch (e) {
            if (e instanceof ApiError && [404, 405, 410].includes(e.status)) {
              // фоллбек на старый «каталоговый» роут
              resp = await apiGet(`/catalog/search?${params.toString()}`, { timeoutMs: 20000 });
            } else {
              throw e;
            }
          }

          if (cancelled) return;

          // нормализуем в массив треков: hits | tracks | items
          const pageHits: Track[] =
            Array.isArray((resp as SearchResp)?.hits)
              ? (resp as SearchResp).hits
              : Array.isArray((resp as UniversalSearchResp)?.tracks)
                ? (resp as UniversalSearchResp).tracks!
                : Array.isArray((resp as MaybeCatalogResp)?.items)
                  ? (resp as MaybeCatalogResp).items!
                  : [];

          acc.push(...pageHits);

          if (typeof (resp as any)?.total === "number") {
            totalValue = (resp as any).total;
          }

          offset += PAGE;

          const got = pageHits.length;
          if (got < PAGE) break;
          if (totalValue != null && acc.length >= totalValue) break;
        }

        if (!cancelled) {
          setItems(acc);
          setTotal(totalValue ?? acc.length);
        }
      })()
        .catch(() => {
          if (!cancelled) {
            setItems([]);
            setTotal(0);
          }
        })
        .finally(() => {
          if (!cancelled) setLoading(false);
        });
    }, 300);

    return () => {
      cancelled = true;
      clearTimeout(timer);
    };
  }, [q]);

  const s = q.trim();
  const openArtist = (name: string) => goArtist(name);

  const [enter, setEnter] = useState(false);
  const enterKey = (() => {
    switch (route.name) {
      case "artist":
        return `artist:${(route as any).artist}`;
      case "artists":
        return `artists:${(route as any).which}`;
      case "playlist":
        return "playlist";
      case "publicPlaylist":
        return `public:${(route as any).handle}`;
      default:
        return String((route as any).name || "home");
    }
  })();

  useEffect(() => {
    window.scrollTo({ top: 0, behavior: "instant" as ScrollBehavior });
    const t = setTimeout(() => setEnter(true), 0);
    return () => {
      clearTimeout(t);
      setEnter(false);
    };
  }, [enterKey]);

  useEffect(() => {
    (window as any).__ogmaSetSearch = (val: string) => setQ(val);
    return () => {
      delete (window as any).__ogmaSetSearch;
    };
  }, []);

  useEffect(() => {
    const handler = (e: any) => {
      const tr: Track | null = e?.detail?.track || null;
      if (tr) openAddPopover(tr);
    };
    window.addEventListener("ogma:add-to-playlist", handler as any);
    return () => window.removeEventListener("ogma:add-to-playlist", handler as any);
  }, [openAddPopover]);

  const isProfile = route.name === "profile";

  return (
    <AuthGate>
      <div className="min-h-screen pb-28 bg-zinc-50 dark:bg-zinc-950 text-zinc-900 dark:text-zinc-100">
        <div
          className={
            "max-w-3xl mx-auto " +
            (isProfile ? "p-4" : "p-4") + // одинаковые поля и для профиля
            " space-y-4 transition-all duration-200 " +
            (enter ? "opacity-100 translate-y-0" : "opacity-0 translate-y-1")
          }
        >
          {!isProfile && (
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <button
                  onClick={goPlaylist}
                  className="text-2xl font-bold hover:opacity-90 truncate max-w-[70vw]" //  чтобы длинные имена не ломали верстку
                  title={`Открыть плейлист: ${playlistTitle}`} // понятный title с именем
                  aria-label={`Открыть плейлист: ${playlistTitle}`} //  a11y
                >
                  {playlistTitle}
                </button>
              </div>
              <UserAvatar />
            </div>
          )}

          {!isProfile && (
            <div className="flex gap-2">
              <form
                className="relative flex-1"
                onSubmit={(e) => {
                  e.preventDefault();
                  const s2 = q.trim();
                  if (s2) window.location.hash = "/";
                }}
              >
                <input
                  value={q}
                  onChange={(e) => setQ(e.target.value)}
                  onKeyDown={(e) => {
                    if (e.key === "Escape") setQ("");
                  }}
                  placeholder="Поиск по названию, артистам, хештегам…"
                  className={
                    "w-full rounded-xl px-4 py-2 bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800 " +
                    (q.trim().length > 0 ? "pr-11" : "pr-4")
                  }
                />
                {q.trim().length > 0 && (
                  <button
                    type="button"
                    onClick={() => setQ("")}
                    aria-label="Очистить поиск"
                    className="absolute right-2 top-1/2 -translate-y-1/2 p-1 h-7 w-7 flex items-center justify-center rounded-full bg-transparent text-zinc-400 hover:text-zinc-700 dark:text-zinc-400 dark:hover:text-zinc-200"
                  >
                    ×
                  </button>
                )}
              </form>
            </div>
          )}

          {!isProfile && (
            <div className="text-sm text-zinc-500">
              {loading ? "Загружаем…" : s ? `Найдено: ${total ?? items.length}` : null}
            </div>
          )}

          {route.name === "playlist" ? (
            <PlaylistPage
              key="playlist"
              onBack={goBackSmart}
              nowId={now?.id ?? null}
              paused={paused}
              onToggleTrack={toggleTrack}
            />
          ) : route.name === "publicPlaylist" ? (
            <PublicPlaylistPage
              key={`public:${route.handle}`}
              handle={route.handle}
              onBack={goBackSmart}
              nowId={now?.id ?? null}
              paused={paused}
              onToggleTrack={(list, idx) => toggleTrack(list, idx, list[idx]?.id)}
            />
          ) : route.name === "artists" ? (
            <ArtistsListPage
              key={`artists:${route.which}`}
              which={route.which}
              onBack={goBackSmart}
              onOpenArtist={openArtist}
            />
          ) : route.name === "artist" ? (
            <ArtistPage
              key={`artist:${route.artist}`}
              artist={route.artist}
              onBack={goBackSmart}
              nowId={now?.id ?? null}
              paused={paused}
              onToggleTrack={toggleTrack}
            />
          ) : route.name === "profile" ? (
            <ProfilePage nowId={now?.id ?? null} paused={paused} />
          ) : s ? (
            <div className="space-y-3">
              {items.map((t, i) => (
                <TrackCard
                  key={t.id}
                  t={t}
                  isActive={now?.id === t.id}
                  isPaused={paused}
                  onToggle={() => toggleTrack(items, i, t.id)}
                />
              ))}
            </div>
          ) : (
            <div className="space-y-4">
              {recsShuffled.length > 0 && (
                <TracksCarousel
                  tracks={recsShuffled}
                  nowId={now?.id ?? null}
                  paused={paused}
                  onToggle={(list, idx) => toggleTrack(list, idx, list[idx].id)}
                  autoplay
                  autoplayDelay={8000}
                  loop
                  title="Клевый рандом"
                />
              )}

              {/* fallback, если рекомендаций нет */}
              {recsShuffled.length === 0 && !loading && (
                <div className="rounded-2xl border border-zinc-200 dark:border-zinc-800 bg-white/70 dark:bg-zinc-900/60 p-4 text-sm text-zinc-500">
                  Рекомендаций пока нет — попробуйте поиск или подпишитесь на артистов.
                </div>
              )}

              <ProfilePage nowId={now?.id ?? null} paused={paused} embedded />
            </div>
          )}
        </div>
        <GlobalAudioPlayer
          now={now}
          paused={paused}
          onEnded={() => {
            const ok = next(false);
            if (!ok) setPaused(true);
          }}
          onPlayPauseChange={(p) => setPaused(p)}
          onPrev={() => prev(false)}
          onNext={() => next(false)}
          queue={queue}
          currentIndex={qIndex}
          onPickFromQueue={(i) => {
            if (i >= 0 && i < queue.length) {
              setQIndex(i);
              const tr = queue[i];
              setNow(tr);
              setPaused(false);
              try {
                (window as any).__ogmaPlay?.(tr);
              } catch { }
            }
          }}
          shuffle={shuffle}
          onToggleShuffle={(v) => setShuffle(v)}
          onAddToPlaylist={(t) => openAddPopover(t)}
        />
      </div>
      <AddToPlaylistPopover
        open={addOpen}
        anchorRef={addBtnAnchorRef as React.RefObject<HTMLElement>}
        onClose={() => setAddOpen(false)}
        trackTitle={addTrack?.title}
        trackArtists={addTrack?.artists}
        playlists={publicPlaylists}
        disabled={addDisabled}
        containsServer={containsMap}
        // локальный плейлист — просто закрываем (или вставьте свою логику)
        onPickLocal={() => {
          setAddDisabled(true);
          try {
            // TODO: вставить фактическое добавление в локальный плейлист
          } finally {
            setAddDisabled(false);
            setAddOpen(false);
          }
        }}
        // публичный плейлист — мягкий шаблон добавления
        onPickServer={async (p) => {
          if (!addTrack) return;
          setAddDisabled(true);
          try {
            // TODO: вызовите свой API добавления, например:
            // await apiPost(`/playlists/${p.id}/tracks`, { track_id: addTrack.id })
            setContainsMap((m) => ({ ...m, [p.id]: true }));
          } catch { }
          setAddDisabled(false);
          setAddOpen(false);
        }}
      />
    </AuthGate>
  );
}