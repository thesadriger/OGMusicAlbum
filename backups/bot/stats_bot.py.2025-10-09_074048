#!/usr/bin/env python3
from __future__ import annotations

import os
import html
import logging
from typing import Optional, Tuple

import asyncpg
from telegram import Update
from telegram.constants import ParseMode
from telegram.ext import (
    Application, CommandHandler, ContextTypes, AIORateLimiter
)

# ------------------------
# Конфиг / окружение
# ------------------------
BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN")
PG_DSN = os.environ.get("PG_DSN") or os.environ.get("DATABASE_URL") or \
         "postgresql://ogma:ogma_pass@127.0.0.1:5432/ogma"

# Пул соединений создадим в application.bot_data["pool"]
POOL_KEY = "pg_pool"

logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s: %(message)s")
log = logging.getLogger("ogma.bot")

# ------------------------
# Утилиты форматирования
# ------------------------
def esc(s: Optional[str]) -> str:
    return html.escape(s or "")

def parse_args(text: str) -> Tuple[str, int]:
    """
    Разбор аргументов команд: /cmd [period] [limit]
    period: all | 24h | 7d | 30d (по умолчанию 7d)
    limit: целое 1..50 (по умолчанию 10)
    """
    # текст после команды
    parts = [p for p in text.strip().split() if p]
    # parts[0] — сама команда, дальше идут аргументы
    args = parts[1:]
    period = "7d"
    limit = 10

    if len(args) >= 1:
        p = args[0].lower()
        if p in {"all", "24h", "7d", "30d"}:
            period = p
        else:
            # если первым пришло число — это limit
            try:
                limit = max(1, min(50, int(p)))
            except Exception:
                pass

    if len(args) >= 2:
        # вторым аргументом может быть limit (если первым был period)
        try:
            limit = max(1, min(50, int(args[1])))
        except Exception:
            pass

    return period, limit

def where_period_sql(period: str) -> str:
    """
    Возвращает фрагмент WHERE для таблицы listening_seconds (по колонке day),
    либо пустую строку для ALL.
    """
    if period == "all":
        return ""
    if period == "24h":
        # listening_seconds агрегируется по датам; для ~24h возьмём последние 1 сутки по датам
        return "AND ls.day >= CURRENT_DATE - 1"
    if period == "30d":
        return "AND ls.day >= CURRENT_DATE - 30"
    # default 7d:
    return "AND ls.day >= CURRENT_DATE - 7"

def fmt_header(title: str, period: str, limit: int) -> str:
    p = {"all": "за всё время", "24h": "за 24 часа", "7d": "за 7 дней", "30d": "за 30 дней"}[period]
    return f"<b>{esc(title)}</b>\n<i>{p}, top {limit}</i>\n"

# ------------------------
# SQL-запросы
# ------------------------
TOP_TRACKS_SQL = """
SELECT t.id::text AS track_id,
       t.title,
       array_to_string(t.artists, ', ') AS artists,
       SUM(ls.seconds)::int AS seconds_total
FROM listening_seconds ls
JOIN tracks t ON t.id = ls.track_id
WHERE 1=1
  {PERIOD}
GROUP BY t.id, t.title, t.artists
ORDER BY seconds_total DESC
LIMIT $1;
"""

TOP_ARTISTS_SQL = """
SELECT a.artist,
       SUM(ls.seconds)::int AS seconds_total
FROM listening_seconds ls
JOIN tracks t ON t.id = ls.track_id
CROSS JOIN LATERAL unnest(t.artists) AS a(artist)
WHERE 1=1
  {PERIOD}
GROUP BY a.artist
ORDER BY seconds_total DESC
LIMIT $1;
"""

TOP_LISTENERS_SQL = """
SELECT u.telegram_id AS user_id,
       COALESCE(u.username,'—') AS username,
       COALESCE(NULLIF(u.name,''),'') AS name,
       SUM(ls.seconds)::int AS seconds_total
FROM listening_seconds ls
JOIN users u ON u.telegram_id = ls.user_id
WHERE 1=1
  {PERIOD}
GROUP BY u.telegram_id, u.username, u.name
ORDER BY seconds_total DESC
LIMIT $1;
"""

ME_TRACKS_SQL = """
SELECT t.id::text AS track_id,
       t.title,
       array_to_string(t.artists, ', ') AS artists,
       SUM(ls.seconds)::int AS seconds_total
FROM listening_seconds ls
JOIN tracks t ON t.id = ls.track_id
WHERE ls.user_id = $1
  {PERIOD}
GROUP BY t.id, t.title, t.artists
ORDER BY seconds_total DESC
LIMIT $2;
"""

ME_ARTISTS_SQL = """
SELECT a.artist,
       SUM(ls.seconds)::int AS seconds_total
FROM listening_seconds ls
JOIN tracks t ON t.id = ls.track_id
CROSS JOIN LATERAL unnest(t.artists) AS a(artist)
WHERE ls.user_id = $1
  {PERIOD}
GROUP BY a.artist
ORDER BY seconds_total DESC
LIMIT $2;
"""

# ------------------------
# Хэндлеры команд
# ------------------------
async def cmd_start(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    text = (
        "<b>OGMA — статистика прослушиваний</b>\n\n"
        "Доступные команды:\n"
        "• /me — ваш Telegram ID\n"
        "• /top_tracks [period] [limit]\n"
        "• /top_artists [period] [limit]\n"
        "• /listeners [period] [limit]\n"
        "• /me_tracks [period] [limit]\n"
        "• /me_artists [period] [limit]\n\n"
        "<i>period:</i> all | 24h | 7d | 30d (по умолчанию 7d)\n"
        "<i>limit:</i> 1..50 (по умолчанию 10)"
    )
    await update.effective_chat.send_message(text, parse_mode=ParseMode.HTML, disable_web_page_preview=True)

async def cmd_me(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    u = update.effective_user
    text = f"<b>Ваш Telegram ID:</b> <code>{u.id}</code>\n" \
           f"<b>username:</b> {esc('@'+u.username) if u.username else '—'}\n" \
           f"<b>name:</b> {esc(u.full_name)}"
    await update.effective_chat.send_message(text, parse_mode=ParseMode.HTML)

async def cmd_top_tracks(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    period, limit = parse_args(update.message.text)
    where = where_period_sql(period)
    sql = TOP_TRACKS_SQL.format(PERIOD=where)
    pool: asyncpg.Pool = ctx.bot_data[POOL_KEY]

    rows = await pool.fetch(sql, limit)
    if not rows:
        await update.effective_chat.send_message("Данных пока нет.", parse_mode=ParseMode.HTML)
        return

    out = [fmt_header("Топ треков", period, limit)]
    for i, r in enumerate(rows, 1):
        out.append(f"{i}. {esc(r['title'])} — {esc(r['artists'])}  <code>{r['seconds_total']}s</code>")
    await update.effective_chat.send_message("\n".join(out), parse_mode=ParseMode.HTML)

async def cmd_top_artists(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    period, limit = parse_args(update.message.text)
    where = where_period_sql(period)
    sql = TOP_ARTISTS_SQL.format(PERIOD=where)
    pool: asyncpg.Pool = ctx.bot_data[POOL_KEY]

    rows = await pool.fetch(sql, limit)
    if not rows:
        await update.effective_chat.send_message("Данных пока нет.", parse_mode=ParseMode.HTML)
        return

    out = [fmt_header("Топ артистов", period, limit)]
    for i, r in enumerate(rows, 1):
        out.append(f"{i}. {esc(r['artist'])}  <code>{r['seconds_total']}s</code>")
    await update.effective_chat.send_message("\n".join(out), parse_mode=ParseMode.HTML)

async def cmd_listeners(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    period, limit = parse_args(update.message.text)
    where = where_period_sql(period)
    sql = TOP_LISTENERS_SQL.format(PERIOD=where)
    pool: asyncpg.Pool = ctx.bot_data[POOL_KEY]

    rows = await pool.fetch(sql, limit)
    if not rows:
        await update.effective_chat.send_message("Данных пока нет.", parse_mode=ParseMode.HTML)
        return

    out = [fmt_header("Топ слушателей", period, limit)]
    for i, r in enumerate(rows, 1):
        uname = (f"@{r['username']}" if r['username'] and r['username'] != '—' else '—')
        name = r['name'] or ''
        out.append(
            f"{i}. <code>{r['user_id']}</code> {esc(uname)} {esc(name)}  "
            f"<code>{r['seconds_total']}s</code>"
        )
    await update.effective_chat.send_message("\n".join(out), parse_mode=ParseMode.HTML)

async def cmd_me_tracks(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    period, limit = parse_args(update.message.text)
    where = where_period_sql(period)
    sql = ME_TRACKS_SQL.format(PERIOD=where)
    pool: asyncpg.Pool = ctx.bot_data[POOL_KEY]

    rows = await pool.fetch(sql, user_id, limit)
    if not rows:
        await update.effective_chat.send_message("Для вашего аккаунта ещё нет данных.", parse_mode=ParseMode.HTML)
        return

    out = [fmt_header("Ваши треки по секундам", period, limit)]
    for i, r in enumerate(rows, 1):
        out.append(f"{i}. {esc(r['title'])} — {esc(r['artists'])}  <code>{r['seconds_total']}s</code>")
    await update.effective_chat.send_message("\n".join(out), parse_mode=ParseMode.HTML)

async def cmd_me_artists(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    period, limit = parse_args(update.message.text)
    where = where_period_sql(period)
    sql = ME_ARTISTS_SQL.format(PERIOD=where)
    pool: asyncpg.Pool = ctx.bot_data[POOL_KEY]

    rows = await pool.fetch(sql, user_id, limit)
    if not rows:
        await update.effective_chat.send_message("Для вашего аккаунта ещё нет данных.", parse_mode=ParseMode.HTML)
        return

    out = [fmt_header("Ваши артисты по секундам", period, limit)]
    for i, r in enumerate(rows, 1):
        out.append(f"{i}. {esc(r['artist'])}  <code>{r['seconds_total']}s</code>")
    await update.effective_chat.send_message("\n".join(out), parse_mode=ParseMode.HTML)

# ------------------------
# Инициализация/запуск
# ------------------------
async def on_start(app: Application):
    # создаём пул к БД
    app.bot_data[POOL_KEY] = await asyncpg.create_pool(dsn=PG_DSN, min_size=1, max_size=5)
    log.info("DB pool ready")

async def on_stop(app: Application):
    pool: asyncpg.Pool = app.bot_data.get(POOL_KEY)
    if pool:
        await pool.close()

def main():
    if not BOT_TOKEN:
        raise RuntimeError("TELEGRAM_BOT_TOKEN is not set")

    application = Application.builder() \
        .token(BOT_TOKEN) \
        .rate_limiter(AIORateLimiter(max_retries=2)) \
        .build()

    application.add_handler(CommandHandler(["start","help"], cmd_start))
    application.add_handler(CommandHandler("me", cmd_me))
    application.add_handler(CommandHandler("top_tracks", cmd_top_tracks))
    application.add_handler(CommandHandler("top_artists", cmd_top_artists))
    application.add_handler(CommandHandler("listeners", cmd_listeners))
    application.add_handler(CommandHandler("me_tracks", cmd_me_tracks))
    application.add_handler(CommandHandler("me_artists", cmd_me_artists))

    application.post_init = on_start
    application.post_stop = on_stop

    application.run_polling(close_loop=False)

if __name__ == "__main__":
    main()
