# /home/ogma/ogma/app/api/playlists.py
from __future__ import annotations

import os
import re
import hmac
import json
import uuid
import time
import base64
import hashlib
import urllib.parse
from pydantic import BaseModel
from fastapi import Body, status

from uuid import UUID

from typing import Optional

import asyncpg
from fastapi import APIRouter, Depends, HTTPException, Query, Body, Header, Request, Cookie

from app.api.users import _get_pool  # общий пул


class PlaylistCreate(BaseModel):
    title: str
    is_public: bool = False
    handle: Optional[str] = None

class HandleUpdate(BaseModel):
    handle: Optional[str] = None

class RemoveItemBody(BaseModel):
    track_id: str

class RemoveBody(BaseModel):
    track_id: Optional[str] = None
    msg_id: Optional[int] = None
    chat: Optional[str] = None


router = APIRouter()

JWT_SECRET = os.environ.get("API_JWT_SECRET") or ""
BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN") or os.environ.get("BOT_TOKEN") or ""

HANDLE_RE = re.compile(r"^[a-z0-9_]{3,32}$")


def _clean_handle(s: Optional[str]) -> Optional[str]:
    if not s:
        return None
    s = s.strip().lstrip("@").lower()
    return s or None


# --- мини-JWT (HS256) без внешних либ -----------------------------------------
def _b64url_decode(data: str) -> bytes:
    pad = "=" * (-len(data) % 4)
    return base64.urlsafe_b64decode(data + pad)


def _b64url_encode(b: bytes) -> str:
    return base64.urlsafe_b64encode(b).rstrip(b"=").decode()


def _parse_jwt_hs256(token: str, secret: str) -> Optional[dict]:
    try:
        h_b64, p_b64, s_b64 = token.split(".")
    except ValueError:
        return None
    try:
        header = json.loads(_b64url_decode(h_b64))
        payload = json.loads(_b64url_decode(p_b64))
    except Exception:
        return None
    if not isinstance(header, dict) or header.get("alg") != "HS256":
        return None
    mac = hmac.new(secret.encode(), msg=f"{h_b64}.{p_b64}".encode(), digestmod=hashlib.sha256).digest()
    sig_ok = hmac.compare_digest(_b64url_encode(mac), s_b64)
    if not sig_ok:
        return None
    exp = payload.get("exp")
    if isinstance(exp, (int, float)) and time.time() > float(exp):
        return None
    return payload


# --- Telegram WebApp initData verification ------------------------------------
def _tg_init_secret(bot_token: str) -> bytes:
    return hmac.new(b"WebAppData", bot_token.encode(), hashlib.sha256).digest()


def _verify_tg_initdata(raw: str, bot_token: str) -> Optional[dict]:
    """
    raw — строка вида "query_id=...&user=...&auth_date=...&hash=..."
    """
    if not bot_token:
        return None
    params = urllib.parse.parse_qs(raw, keep_blank_values=True, strict_parsing=False)
    params = {k: v[-1] for k, v in params.items()}
    given_hash = params.pop("hash", None)
    if not given_hash:
        return None

    data_check_string = "\n".join(f"{k}={params[k]}" for k in sorted(params.keys()))
    secret = _tg_init_secret(bot_token)
    mac = hmac.new(secret, msg=data_check_string.encode(), digestmod=hashlib.sha256).hexdigest()
    if not hmac.compare_digest(mac, given_hash):
        return None

    auth_date = params.get("auth_date")
    if auth_date and auth_date.isdigit():
        ts = int(auth_date)
        if ts < time.time() - 24 * 3600:
            return None

    try:
        user = json.loads(params.get("user", "{}"))
    except Exception:
        user = {}
    if not isinstance(user, dict):
        user = {}

    return {
        "user": user,
        "auth_date": int(params.get("auth_date", "0") or 0),
        "query_id": params.get("query_id"),
    }


# ---------- удаление по ID плейлиста ----------
@router.delete("/playlists/{playlist_id}/items/{track_id}")
async def remove_item_by_path(
    playlist_id: str,
    track_id: str,
    conn = Depends(db),                # замени на свою зависимость
    user = Depends(get_current_user),  # и это тоже
):
    await _ensure_owner(conn, playlist_id, user.id)
    deleted = await _delete_item(conn, playlist_id, track_id=track_id)
    if deleted == 0:
        raise HTTPException(404, "Track not found in playlist")
    return {"ok": True}

@router.delete("/playlists/{playlist_id}/items")
async def remove_item_by_query(
    playlist_id: str,
    track_id: Optional[str] = Query(None),
    msg_id: Optional[int] = Query(None),
    chat: Optional[str] = Query(None),
    conn = Depends(db),
    user = Depends(get_current_user),
):
    await _ensure_owner(conn, playlist_id, user.id)
    deleted = await _delete_item(conn, playlist_id, track_id, msg_id, chat)
    if deleted == 0:
        raise HTTPException(404, "Item not found")
    return {"ok": True}

@router.post("/playlists/{playlist_id}/items/remove")
async def remove_item_by_body(
    playlist_id: str,
    body: RemoveBody = Body(...),
    conn = Depends(db),
    user = Depends(get_current_user),
):
    await _ensure_owner(conn, playlist_id, user.id)
    deleted = await _delete_item(conn, playlist_id, body.track_id, body.msg_id, body.chat)
    if deleted == 0:
        raise HTTPException(404, "Item not found")
    return {"ok": True}

# ---------- удаление по HANDLE плейлиста ----------
@router.delete("/playlists/by-handle/{handle}/items/{track_id}")
async def remove_item_public_by_path(
    handle: str,
    track_id: str,
    conn = Depends(db),
    user = Depends(get_current_user),
):
    playlist_id = await _playlist_id_by_handle(conn, handle)
    if not playlist_id:
        raise HTTPException(404, "Playlist not found")
    await _ensure_owner(conn, playlist_id, user.id)
    deleted = await _delete_item(conn, playlist_id, track_id=track_id)
    if deleted == 0:
        raise HTTPException(404, "Track not found in playlist")
    return {"ok": True}

@router.delete("/playlists/by-handle/{handle}/items")
async def remove_item_public_by_query(
    handle: str,
    track_id: Optional[str] = Query(None),
    msg_id: Optional[int] = Query(None),
    chat: Optional[str] = Query(None),
    conn = Depends(db),
    user = Depends(get_current_user),
):
    playlist_id = await _playlist_id_by_handle(conn, handle)
    if not playlist_id:
        raise HTTPException(404, "Playlist not found")
    await _ensure_owner(conn, playlist_id, user.id)
    deleted = await _delete_item(conn, playlist_id, track_id, msg_id, chat)
    if deleted == 0:
        raise HTTPException(404, "Item not found")
    return {"ok": True}

@router.post("/playlists/by-handle/{handle}/items/remove")
async def remove_item_public_by_body(
    handle: str,
    body: RemoveBody = Body(...),
    conn = Depends(db),
    user = Depends(get_current_user),
):
    playlist_id = await _playlist_id_by_handle(conn, handle)
    if not playlist_id:
        raise HTTPException(404, "Playlist not found")
    await _ensure_owner(conn, playlist_id, user.id)
    deleted = await _delete_item(conn, playlist_id, body.track_id, body.msg_id, body.chat)
    if deleted == 0:
        raise HTTPException(404, "Item not found")
    return {"ok": True}

async def _ensure_owner(conn, playlist_id: str, user_id: int):
    owner = await conn.fetchval(
        "select user_id from playlists where id = $1", playlist_id
    )
    if owner is None:
        raise HTTPException(404, "Playlist not found")
    if owner != user_id:
        raise HTTPException(403, "Forbidden")

async def _delete_item(conn, playlist_id: str,
                       track_id: Optional[str] = None,
                       msg_id: Optional[int] = None,
                       chat: Optional[str] = None) -> int:
    if track_id:
        res = await conn.execute(
            "delete from playlist_items where playlist_id = $1 and track_id = $2",
            playlist_id, track_id
        )
        # conn.execute обычно возвращает строку вида "DELETE 1"
        try:
            return int(res.split()[-1])
        except Exception:
            return 0
    if msg_id is not None and chat:
        chat = chat.lstrip("@")
        res = await conn.execute(
            """
            delete from playlist_items
            where playlist_id = $1
              and source_msg_id = $2
              and lower(source_chat) = lower($3)
            """,
            playlist_id, msg_id, chat
        )
        try:
            return int(res.split()[-1])
        except Exception:
            return 0
    return 0

async def _playlist_id_by_handle(conn, handle: str) -> Optional[str]:
    clean = handle.lstrip("@").lower()
    return await conn.fetchval(
        "select id from playlists where lower(handle) = $1",
        clean
    )


async def _ensure_db_user(con: asyncpg.Connection, uid: int) -> None:
    await con.execute(
        "INSERT INTO users (telegram_id) VALUES ($1) ON CONFLICT (telegram_id) DO NOTHING",
        uid,
    )


async def _ensure_default_playlist(con: asyncpg.Connection, user_id: int) -> str:
    row = await con.fetchrow(
        """
        INSERT INTO playlists (user_id, title, kind)
        VALUES ($1, 'Мой плейлист', 'custom')
        ON CONFLICT (user_id, title) DO UPDATE SET title = EXCLUDED.title
        RETURNING id::text
        """,
        user_id,
    )
    return row["id"]


async def get_current_user(
    request: Request,
    pool: asyncpg.Pool = Depends(_get_pool),
    x_user_id: Optional[int] = Header(default=None, alias="X-User-Id"),
    authorization: Optional[str] = Header(default=None, alias="Authorization"),
    x_tg_init: Optional[str] = Header(default=None, alias="X-Telegram-Init-Data"),
    init_qs: Optional[str] = Query(default=None, alias="init"),
    ogma_session: Optional[str] = Cookie(default=None, alias="ogma_session"),
) -> int:
    """
    Возвращает telegram_id текущего пользователя.
    Источники (приоритет):
      1) X-User-Id (dev / внутренний прокси)
      2) Authorization: Bearer <JWT HS256> (payload.uid|sub)
      3) Cookie ogma_session=<JWT HS256>
      4) X-Telegram-Init-Data (webapp) / ?init=
    Успешная авторизация → ensure user + ensure default playlist.
    """
    uid: Optional[int] = None

    if x_user_id:
        try:
            uid = int(x_user_id)
        except Exception:
            raise HTTPException(401, "Bad X-User-Id")

    if uid is None and authorization and authorization.lower().startswith("bearer "):
        token = authorization.split(None, 1)[1].strip()
        if JWT_SECRET:
            payload = _parse_jwt_hs256(token, JWT_SECRET)
            if payload:
                cand = payload.get("uid") or payload.get("sub")
                if isinstance(cand, int) or (isinstance(cand, str) and cand.isdigit()):
                    uid = int(cand)

    if uid is None and ogma_session and JWT_SECRET:
        payload = _parse_jwt_hs256(ogma_session, JWT_SECRET)
        if payload:
            cand = payload.get("uid") or payload.get("sub")
            if isinstance(cand, int) or (isinstance(cand, str) and cand.isdigit()):
                uid = int(cand)

    if uid is None and (x_tg_init or init_qs):
        raw = x_tg_init or init_qs or ""
        v = _verify_tg_initdata(raw, BOT_TOKEN)
        if v and isinstance(v.get("user"), dict):
            tg_user = v["user"]
            cand = tg_user.get("id")
            if isinstance(cand, int) or (isinstance(cand, str) and str(cand).isdigit()):
                uid = int(cand)

    if uid is None:
        raise HTTPException(401, "Unauthorized")

    async with pool.acquire() as con:
        await _ensure_db_user(con, uid)
        await _ensure_default_playlist(con, uid)

    return uid

async def _delete_item(con: asyncpg.Connection, pid: uuid.UUID, tid: uuid.UUID) -> int:
    tag = await con.execute(
        "DELETE FROM playlist_items WHERE playlist_id=$1 AND track_id=$2",
        pid, tid
    )
    try:
        return int(tag.split()[-1])  # "DELETE 1" → 1
    except Exception:
        return 0

# -----------------------------------------------------------------------------
#                                 РУЧКИ
# -----------------------------------------------------------------------------

@router.get("/playlists")
async def list_playlists(
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    async with pool.acquire() as con:
        rows = await con.fetch(
            """
            SELECT p.id::text, p.user_id, p.title, p.kind, p.is_public, p.handle,
                   p.created_at, p.updated_at,
                   (SELECT COUNT(*) FROM playlist_items i WHERE i.playlist_id=p.id) AS item_count
            FROM playlists p
            WHERE p.user_id = $1
            ORDER BY p.updated_at DESC, p.created_at DESC
            """,
            user_id,
        )
    return {"items": [dict(r) for r in rows]}


@router.post("/playlists", status_code=status.HTTP_201_CREATED)
async def create_playlist(
    payload: Optional[PlaylistCreate] = Body(default=None),
    title_q: Optional[str] = Query(default=None, alias="title"),
    is_public_q: bool = Query(default=False, alias="is_public"),
    handle_q: Optional[str] = Query(default=None, alias="handle"),
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    if payload is not None:
        title = (payload.title or "").strip()
        is_public = bool(payload.is_public)
        handle = payload.handle
    else:
        title = (title_q or "").strip() if title_q is not None else ""
        is_public = bool(is_public_q)
        handle = handle_q

    if not title:
        raise HTTPException(400, "Title is required")

    h = _clean_handle(handle)
    if h is not None and not HANDLE_RE.fullmatch(h):
        raise HTTPException(400, "Handle must match ^[a-z0-9_]{3,32}$")

    async with pool.acquire() as con:
        if h is not None:
            exists = await con.fetchval(
                "SELECT 1 FROM playlists WHERE lower(handle)=lower($1)", h
            )
            if exists:
                raise HTTPException(409, "Handle is already taken")

        try:
            row = await con.fetchrow(
                """
                INSERT INTO playlists (user_id, title, kind, is_public, handle)
                VALUES ($1, $2, 'custom', $3, $4)
                ON CONFLICT (user_id, title) DO UPDATE
                  SET is_public = EXCLUDED.is_public,
                      updated_at = now()
                RETURNING id::text, user_id, title, kind, is_public, handle, created_at, updated_at
                """,
                user_id, title, is_public, h,
            )
        except asyncpg.UniqueViolationError:
            raise HTTPException(409, "Playlist with this title already exists for this user")

    return dict(row)


@router.patch("/playlists/{playlist_id}/handle", status_code=status.HTTP_200_OK)
async def set_playlist_handle(
    playlist_id: str,
    payload: HandleUpdate,
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    try:
        pid = uuid.UUID(playlist_id)
    except Exception:
        raise HTTPException(400, "Invalid playlist_id")

    h = _clean_handle(payload.handle)
    if h is not None and not HANDLE_RE.fullmatch(h):
        raise HTTPException(400, "Handle must match ^[a-z0-9_]{3,32}$")

    async with pool.acquire() as con:
        owner = await con.fetchval("SELECT user_id FROM playlists WHERE id=$1", pid)
        if owner is None:
            raise HTTPException(404, "Playlist not found")
        if owner != user_id:
            raise HTTPException(403, "Forbidden")

        if h is not None:
            exists = await con.fetchval(
                "SELECT 1 FROM playlists WHERE lower(handle)=lower($1) AND id<>$2",
                h, pid,
            )
            if exists:
                raise HTTPException(409, "Handle is already taken")

        row = await con.fetchrow(
            """
            UPDATE playlists
               SET handle = $2,
                   updated_at = now()
             WHERE id = $1
         RETURNING id::text, user_id, title, kind, is_public, handle, created_at, updated_at
            """,
            pid, h,
        )
    return dict(row)


@router.get("/playlists/default")
async def get_or_create_default_playlist(
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    async with pool.acquire() as con:
        pid = await _ensure_default_playlist(con, user_id)
        row = await con.fetchrow(
            """
            SELECT p.id::text, p.user_id, p.title, p.kind, p.is_public, p.handle,
                   p.created_at, p.updated_at,
                   (SELECT COUNT(*) FROM playlist_items i WHERE i.playlist_id=p.id) AS item_count
            FROM playlists p WHERE p.id = $1
            """,
            pid,
        )
    return dict(row)


@router.get("/playlists/{playlist_id}/items")
async def get_playlist_items(
    playlist_id: str,
    limit: int = Query(50, ge=1, le=200),
    offset: int = Query(0, ge=0),
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    try:
        pid = uuid.UUID(playlist_id)
    except Exception:
        raise HTTPException(400, "Invalid playlist_id")

    async with pool.acquire() as con:
        owner = await con.fetchval("SELECT user_id FROM playlists WHERE id=$1", pid)
        if owner is None:
            raise HTTPException(404, "Playlist not found")
        if owner != user_id:
            raise HTTPException(403, "Forbidden")

        rows = await con.fetch(
            """
            SELECT
              t.id::text          AS id,
              t.tg_msg_id         AS "msgId",
              t.chat_username     AS chat,
              t.title, t.artists, t.hashtags,
              t.duration_s        AS duration,
              t.mime, t.size_bytes, t.created_at,
              i.position, i.added_at
            FROM playlist_items i
            JOIN tracks t ON t.id = i.track_id
            WHERE i.playlist_id = $1
            ORDER BY i.position
            LIMIT $2 OFFSET $3
            """,
            pid, limit, offset,
        )
        total = await con.fetchval(
            "SELECT COUNT(*) FROM playlist_items WHERE playlist_id=$1", pid
        )

    return {
        "items": [dict(r) for r in rows],
        "limit": limit,
        "offset": offset,
        "total": total,
    }


@router.post("/playlists/{playlist_id}/items")
async def add_item_to_playlist(
    playlist_id: str,
    track_id: str,
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
    x_method_override: Optional[str] = Header(default=None, alias="X-HTTP-Method-Override"),
):
    try:
        pid = uuid.UUID(playlist_id)
        tid = uuid.UUID(track_id)
    except Exception:
        raise HTTPException(400, "Invalid UUID")

    async with pool.acquire() as con:
        owner = await con.fetchval("SELECT user_id FROM playlists WHERE id=$1", pid)
        if owner is None:
            raise HTTPException(404, "Playlist not found")
        if owner != user_id:
            raise HTTPException(403, "Forbidden")

        # Если пришёл метод-оверрайд на DELETE — выполняем удаление (fallback из фронта)
        if (x_method_override or "").strip().upper() == "DELETE":
            n = await _delete_item(con, pid, tid)
            if n == 0:
                raise HTTPException(404, "Item not found")
            return {"ok": True}

        exists = await con.fetchval("SELECT 1 FROM tracks WHERE id=$1", tid)
        if not exists:
            raise HTTPException(404, "Track not found")

        await con.execute(
            """
            INSERT INTO playlist_items (playlist_id, track_id)
            VALUES ($1, $2)
            ON CONFLICT (playlist_id, track_id) DO NOTHING
            """,
            pid, tid,
        )
        row = await con.fetchrow(
            "SELECT position, added_at FROM playlist_items WHERE playlist_id=$1 AND track_id=$2",
            pid, tid,
        )
    return {"playlist_id": str(pid), "track_id": str(tid), **(dict(row) if row else {})}


@router.delete("/playlists/{playlist_id}/items/{track_id}")
async def remove_item_by_path(
    playlist_id: str,
    track_id: str,
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    try:
        pid = uuid.UUID(playlist_id)
        tid = uuid.UUID(track_id)
    except Exception:
        raise HTTPException(400, "Invalid UUID")

    async with pool.acquire() as con:
        owner = await con.fetchval("SELECT user_id FROM playlists WHERE id=$1", pid)
        if owner is None:
            raise HTTPException(404, "Playlist not found")
        if owner != user_id:
            raise HTTPException(403, "Forbidden")

        n = await _delete_item(con, pid, tid)
        if n == 0:
            raise HTTPException(404, "Item not found")
    return {"ok": True}


@router.delete("/playlists/{playlist_id}/items")
async def remove_item_by_query(
    playlist_id: str,
    track_id: str = Query(...),
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    return await remove_item_by_path(playlist_id, track_id, pool, user_id)


@router.post("/playlists/{playlist_id}/items/remove")
async def remove_item_by_post(
    playlist_id: str,
    body: RemoveItemBody,
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    return await remove_item_by_path(playlist_id, body.track_id, pool, user_id)


@router.delete("/playlists/{playlist_id}")
async def delete_playlist(
    playlist_id: str,
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    try:
        pid = uuid.UUID(playlist_id)
    except Exception:
        raise HTTPException(400, "Invalid playlist_id")

    async with pool.acquire() as con:
        owner = await con.fetchval("SELECT user_id FROM playlists WHERE id=$1", pid)
        if owner is None:
            raise HTTPException(404, "Playlist not found")
        if owner != user_id:
            raise HTTPException(403, "Forbidden")

        async with con.transaction():
            await con.execute("DELETE FROM playlist_items WHERE playlist_id=$1", pid)
            await con.execute("DELETE FROM playlists WHERE id=$1", pid)

    return {"ok": True}


# Фоллбек, если DELETE режется по пути
@router.post("/playlists/{playlist_id}/delete")
async def delete_playlist_post(
    playlist_id: str,
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    return await delete_playlist(playlist_id, pool, user_id)


@router.delete("/playlists/by-handle/{handle}")
async def delete_playlist_by_handle(
    handle: str,
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    h = _clean_handle(handle)
    if not h or not HANDLE_RE.fullmatch(h):
        raise HTTPException(400, "Invalid handle format")

    async with pool.acquire() as con:
        row = await con.fetchrow(
            "SELECT id, user_id FROM playlists WHERE lower(handle)=lower($1)",
            h,
        )
        if not row:
            raise HTTPException(404, "Playlist not found")
        pid = row["id"]
        owner = row["user_id"]
        if owner != user_id:
            raise HTTPException(403, "Forbidden")

        async with con.transaction():
            await con.execute("DELETE FROM playlist_items WHERE playlist_id=$1", pid)
            await con.execute("DELETE FROM playlists WHERE id=$1", pid)

    return {"ok": True}


# Фоллбек для by-handle
@router.post("/playlists/by-handle/{handle}/delete")
async def delete_playlist_by_handle_post(
    handle: str,
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    return await delete_playlist_by_handle(handle, pool, user_id)


# ---------- Публичные ручки по @handle (только для публичных плейлистов) ------

@router.get("/playlists/by-handle/{handle}")
async def get_public_playlist_by_handle(
    handle: str,
    pool: asyncpg.Pool = Depends(_get_pool),
):
    h = _clean_handle(handle)
    if not h or not HANDLE_RE.fullmatch(h):
        raise HTTPException(400, "Invalid handle format")
    async with pool.acquire() as con:
        row = await con.fetchrow(
            """
            SELECT id::text, user_id, title, kind, is_public, handle, created_at, updated_at
            FROM playlists
            WHERE is_public = true AND lower(handle)=lower($1)
            """,
            h,
        )
    if not row:
        raise HTTPException(404, "Playlist not found")
    return dict(row)


@router.get("/playlists/by-handle/{handle}/items")
async def get_public_playlist_items_by_handle(
    handle: str,
    limit: int = Query(50, ge=1, le=200),
    offset: int = Query(0, ge=0),
    pool: asyncpg.Pool = Depends(_get_pool),
):
    h = _clean_handle(handle)
    if not h or not HANDLE_RE.fullmatch(h):
        raise HTTPException(400, "Invalid handle")

    async with pool.acquire() as con:
        pid = await con.fetchval(
            "SELECT id FROM playlists WHERE is_public=true AND lower(handle)=lower($1)",
            h,
        )
        if not pid:
            raise HTTPException(404, "Playlist not found")

        rows = await con.fetch(
            """
            SELECT
              t.id::text AS id,
              t.tg_msg_id AS "msgId",
              t.chat_username AS chat,
              t.title, t.artists, t.hashtags,
              t.duration_s AS duration,
              t.mime, t.size_bytes, t.created_at,
              i.position, i.added_at
            FROM playlist_items i
            JOIN tracks t ON t.id = i.track_id
            WHERE i.playlist_id = $1
            ORDER BY i.position
            LIMIT $2 OFFSET $3
            """,
            pid, limit, offset,
        )
        total = await con.fetchval(
            "SELECT COUNT(*) FROM playlist_items WHERE playlist_id=$1", pid
        )

    return {
        "items": [dict(r) for r in rows],
        "limit": limit,
        "offset": offset,
        "total": total,
    }


@router.delete("/playlists/by-handle/{handle}/items/{track_id}")
async def remove_item_public_by_path(
    handle: str,
    track_id: str,
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    h = _clean_handle(handle)
    if not h or not HANDLE_RE.fullmatch(h):
        raise HTTPException(400, "Invalid handle format")
    try:
        tid = uuid.UUID(track_id)
    except Exception:
        raise HTTPException(400, "Invalid UUID")

    async with pool.acquire() as con:
        row = await con.fetchrow(
            "SELECT id, user_id FROM playlists WHERE is_public=true AND lower(handle)=lower($1)",
            h,
        )
        if not row:
            raise HTTPException(404, "Playlist not found")
        pid, owner = row["id"], row["user_id"]
        if owner != user_id:
            raise HTTPException(403, "Forbidden")

        n = await _delete_item(con, pid, tid)
        if n == 0:
            raise HTTPException(404, "Item not found")
    return {"ok": True}


@router.delete("/playlists/by-handle/{handle}/items")
async def remove_item_public_by_query(
    handle: str,
    track_id: str = Query(...),
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    return await remove_item_public_by_path(handle, track_id, pool, user_id)


@router.post("/playlists/by-handle/{handle}/items")
async def remove_item_public_by_handle_override(
    handle: str,
    track_id: str = Query(...),
    x_method_override: Optional[str] = Header(default=None, alias="X-HTTP-Method-Override"),
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    # Если поступил POST с заголовком X-HTTP-Method-Override: DELETE – удаляем трек
    if (x_method_override or "").strip().upper() == "DELETE":
        return await remove_item_public_by_path(handle, track_id, pool, user_id)
    # Иначе возвращаем ошибку метода
    raise HTTPException(405, "Method Not Allowed")


@router.post("/playlists/by-handle/{handle}/items/remove")
async def remove_item_public_by_post(
    handle: str,
    body: RemoveItemBody,
    pool: asyncpg.Pool = Depends(_get_pool),
    user_id: int = Depends(get_current_user),
):
    return await remove_item_public_by_path(handle, body.track_id, pool, user_id)