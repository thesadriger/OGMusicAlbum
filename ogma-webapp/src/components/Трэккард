import { useEffect, useRef, useState } from "react";
import { useAudioProgressForTrack } from "@/hooks/useAudioProgressForTrack";
import GradientBackdropFill from "@/components/GradientBackdropFill";
import type { Track } from "@/types/types";
import { addToPlaylist, inPlaylist, removeFromPlaylist } from "@/lib/playlists";
import { sendTrackToMe } from "@/lib/api";
import { emitPlayTrack } from "@/hooks/usePlayerBus";
import GradientRing from "@/components/GradientRing";

type Props = {
  t: Track;
  isActive?: boolean;
  isPaused?: boolean;
  onToggle: () => void;
  /** режим:
   *  - "default": вправо = добавить, влево = reveal «Скачать»
   *  - "playlist": вправо = скачать (бот), влево = удалить
   */
  mode?: "default" | "playlist";
};

const TRIGGER_COMMIT = 84;
const MAX_SWIPE = 160;
const LEFT_REVEAL = 96;
const LEFT_MIN_OPEN = 28;
const SCRUB_SENS = 1.5;



// --- параметры натяжения/вибрации ---
const FULL_PULL_PCT = 0.30;           // 100% натяжения = 30% ширины карточки
const BUZZ_MIN_MS = 18;               // у края (0% натяга) — максимально частые пульсы
const BUZZ_MAX_MS = 220;              // чем дальше тянем, тем реже (до полного отключения на 100%)

const clamp = (x: number, a: number, b: number) => Math.max(a, Math.min(b, x));
const lerp = (a: number, b: number, t: number) => a + (b - a) * t;

export function TrackCard({ t, isActive, isPaused, onToggle, mode = "default" }: Props) {
  const startX = useRef<number | null>(null);
  const startY = useRef<number | null>(null);
  const cancelledByScroll = useRef(false);

  // SCRUB: состояния долгого удержания и скраббинга
  const holdTimer = useRef<number | null>(null);
  const [scrubbing, setScrubbing] = useState(false);
  const [scrubPct, setScrubPct] = useState(0);
  const scrubStart = useRef<{ pct: number; x: number; width: number }>({ pct: 0, x: 0, width: 1 });
  const lastProgressRef = useRef(0);

  const [dx, setDx] = useState(0);
  const [drag, setDrag] = useState(false);
  const [anim, setAnim] = useState<"none" | "snap" | "remove">("none");
  const [leftOpen, setLeftOpen] = useState(false);
  const [toast, setToast] = useState<null | "added" | "exists" | "removed" | "sending" | "sent" | "error">(null);

  const toastBgClass =
    toast === "added" || toast === "exists" ? "bg-emerald-600/85" :
      toast === "removed" || toast === "error" ? "bg-red-600/85" :
        toast === "sending" || toast === "sent" ? "bg-blue-600/85" :
          "bg-black/70";

  // для «натяжения»
  const cardRef = useRef<HTMLDivElement | null>(null);
  const fullPullPxRef = useRef(120);               // 30% ширины — уточняется в pointerDown
  const pivotYRef = useRef(50);                    // transform-origin по вертикали (под пальцем), %
  const lastBuzzAtRef = useRef(0);                 // таймстемп последней вибрации
  const crossedRef = useRef({ left: false, right: false, reveal: false }); // антидребезг порогов

  useEffect(() => {
    if (!toast) return;
    const id = setTimeout(() => setToast(null), 900);
    return () => clearTimeout(id);
  }, [toast]);

  const playing = !!isActive && !isPaused;

  // Прогресс конкретного трека
  const progress = useAudioProgressForTrack(t.id, () => {
    const audio = document.querySelector(`audio[data-track-id="${t.id}"]`) as HTMLAudioElement | null;
    const isActiveTrack = !!(t.id && playing);
    return {
      audio,
      isActive: isActiveTrack,
      currentTime: audio?.currentTime,
      duration: audio?.duration,
    };
  });
  const getAudio = () => document.querySelector(`audio[data-track-id="${t.id}"]`) as HTMLAudioElement | null;
  const already = inPlaylist(t.id);

  // прогресс свайпа относительно 30% ширины (0..1)
  const pullPct = clamp(Math.abs(leftOpen ? dx + LEFT_REVEAL : dx) / Math.max(1, fullPullPxRef.current), 0, 1);

  // визуальная «натянутость»: лёгкий поворот и масштаб
  const tiltDeg = clamp((dx / Math.max(1, fullPullPxRef.current)) * 3.2, -4, 4);
  const scaleK = 1 + 0.015 * pullPct;

  const style: React.CSSProperties = {
    transform: scrubbing
      ? "translate3d(0,0,0)"
      : (anim === "remove"
        ? `translate3d(-110%,0,0)`
        : `translate3d(${dx}px,0,0) rotate(${tiltDeg}deg) scale(${scaleK})`),
    transition:
      anim === "snap"
        ? "transform 180ms cubic-bezier(.2,.8,.2,1), opacity 180ms"
        : anim === "remove"
          ? "transform 200ms ease, opacity 200ms ease"
          : "none",
    opacity: anim === "remove" ? 0 : 1,
    touchAction: scrubbing ? "none" : "pan-y",
    overscrollBehavior: "contain",
    overscrollBehaviorY: "contain",
    willChange: "transform, opacity",
    backfaceVisibility: "hidden",
    isolation: "isolate",
    transformOrigin: `50% ${pivotYRef.current}%`,
  };

  const pctRight = clamp(dx / TRIGGER_COMMIT, 0, 1);
  const pctLeft = clamp(-dx / TRIGGER_COMMIT, 0, 1);

  // показываем подложку только когда есть жест/фиксация
  const showBg = drag || Math.abs(dx) > 1 || leftOpen;

  // iOS/Telegram first, fallback to Vibrate API
  const hapticImpact = (kind: "light" | "medium" | "heavy" | "soft" | "rigid" = "light") => {
    try {
      const tg = (window as any)?.Telegram?.WebApp?.HapticFeedback;
      if (tg?.impactOccurred) { tg.impactOccurred(kind); return; }
    } catch { }
    try { navigator.vibrate?.(20); } catch { }
  };

  const hapticTick = () => {
    try {
      const tg = (window as any)?.Telegram?.WebApp?.HapticFeedback;
      // частые «типы» удобнее делать selectionChanged
      if (tg?.selectionChanged) { tg.selectionChanged(); return; }
    } catch { }
    try { navigator.vibrate?.(6); } catch { }
  };

  const commitAdd = () => {
    const { added } = addToPlaylist(t);
    setToast(added ? "added" : "exists");
    hapticImpact(added ? "medium" : "light");
  };

  const commitDownload = async () => {
    setToast("sending");
    hapticImpact("medium");
    try {
      await sendTrackToMe(t);
      setToast("sent");
    } catch {
      setToast("error");
    }
  };

  const onPointerMove = (e: React.PointerEvent) => {
    if (!drag || startX.current == null || startY.current == null) return;

    const deltaX = e.clientX - startX.current;
    const deltaY = e.clientY - startY.current;

    // отдаём приоритет вертикальному скроллу
    if (Math.abs(deltaY) > 8 && Math.abs(deltaY) > Math.abs(deltaX)) {
      cancelledByScroll.current = true;
    }

    // отменяем long-press при явном движении
    if (!scrubbing && holdTimer.current && (Math.abs(deltaX) > 6 || Math.abs(deltaY) > 6)) {
      clearTimeout(holdTimer.current);
      holdTimer.current = null;
    }

    // режим скраба
    if (scrubbing) {
      e.preventDefault();
      const { pct, x, width } = scrubStart.current;
      const dp = ((e.clientX - x) / Math.max(1, width)) * SCRUB_SENS;
      const next = clamp(pct + dp, 0, 1);
      setScrubPct(next);
      lastProgressRef.current = next;
      const a = getAudio();
      if (a && isFinite(a.duration) && a.duration > 0) a.currentTime = next * a.duration;
      return;
    }

    // обычный свайп
    let delta = deltaX;
    if (leftOpen) delta -= -LEFT_REVEAL;
    const limited = delta > 0 ? Math.min(MAX_SWIPE, delta) : Math.max(-MAX_SWIPE, delta);
    const nextDx = leftOpen ? -LEFT_REVEAL + limited : limited;
    setDx(nextDx);

    // адаптивная частота «тики» (iOS haptics / vibrate)
    const pull = clamp(Math.abs(nextDx + (leftOpen ? LEFT_REVEAL : 0)) / Math.max(1, fullPullPxRef.current), 0, 1);
    if (pull < 1) {
      const interval = lerp(BUZZ_MIN_MS, BUZZ_MAX_MS, pull);
      const now = performance.now();
      if (now - lastBuzzAtRef.current >= interval) {
        hapticTick();
        lastBuzzAtRef.current = now;
      }
    }

    // разовые «тычки» на порогах
    if (nextDx >= TRIGGER_COMMIT && !crossedRef.current.right) { hapticImpact("medium"); crossedRef.current.right = true; }
    else if (nextDx < TRIGGER_COMMIT && crossedRef.current.right) { crossedRef.current.right = false; }

    if (nextDx <= -TRIGGER_COMMIT && !crossedRef.current.left) { hapticImpact("medium"); crossedRef.current.left = true; }
    else if (nextDx > -TRIGGER_COMMIT && crossedRef.current.left) { crossedRef.current.left = false; }

    if (nextDx <= -LEFT_MIN_OPEN && !crossedRef.current.reveal) { hapticImpact("light"); crossedRef.current.reveal = true; }
    else if (nextDx > -LEFT_MIN_OPEN && crossedRef.current.reveal) { crossedRef.current.reveal = false; }
  };

  const onPointerDown = (e: React.PointerEvent<HTMLDivElement>) => {
    (e.currentTarget as HTMLElement).setPointerCapture?.(e.pointerId);
    startX.current = e.clientX;
    startY.current = e.clientY;
    cancelledByScroll.current = false;
    setDrag(true);
    setAnim("none");

    // для расчёта 100% натяжения от ширины
    const rect = (e.currentTarget as HTMLElement).getBoundingClientRect();
    fullPullPxRef.current = Math.max(40, rect.width * FULL_PULL_PCT);
    lastBuzzAtRef.current = performance.now();
    crossedRef.current = { left: false, right: false, reveal: false };

    // место касания → ось поворота
    pivotYRef.current = clamp(((e.clientY - rect.top) / Math.max(1, rect.height)) * 100, 0, 100);

    // держим прогресс…
    useEffect(() => {
      if (isActive) {
        if (typeof progress === "number" && !Number.isNaN(progress)) {
          lastProgressRef.current = clamp(progress, 0, 1);
        }
      } else {
        lastProgressRef.current = 0;
      }
    }, [isActive, progress]);

    // глобально блокируем touchmove при скрабе (iOS/TG overscroll)
    useEffect(() => {
      const onTouchMove = (ev: TouchEvent) => { if (scrubbing) ev.preventDefault(); };
      document.addEventListener("touchmove", onTouchMove, { passive: false });
      return () => document.removeEventListener("touchmove", onTouchMove);
    }, [scrubbing]);

    useEffect(() => {
      return () => { if (holdTimer.current) clearTimeout(holdTimer.current); };
    }, []);

    // --- LONG PRESS → SCRUB ---
    const downX = e.clientX;
    if (isActive) {
      if (holdTimer.current) { clearTimeout(holdTimer.current); holdTimer.current = null; }
      holdTimer.current = window.setTimeout(() => {
        const base = typeof progress === "number" ? progress : lastProgressRef.current;
        const pct0 = clamp(Number.isFinite(base as number) ? (base as number) : 0, 0, 1);
        scrubStart.current = { pct: pct0, x: downX, width: rect.width || 1 };
        setScrubPct(pct0);
        setScrubbing(true);
        setLeftOpen(false);
        setDx(0);
        cancelledByScroll.current = true;
        hapticImpact("light"); // вместо vibrate
      }, 300);
    };

  };

  const onPointerCancel = () => {
    if (holdTimer.current) { clearTimeout(holdTimer.current); holdTimer.current = null; }
    if (scrubbing) { setScrubbing(false); }
    cancelledByScroll.current = true;
    setDrag(false);
    setAnim("snap");
    crossedRef.current = { left: false, right: false, reveal: false };
    setDx(leftOpen ? -LEFT_REVEAL : 0);
  };

  const onPointerUp = () => {
    if (!drag) return;
    if (holdTimer.current) { clearTimeout(holdTimer.current); holdTimer.current = null; }
    // SCRUB: завершение
    if (scrubbing) {
      setScrubbing(false);
      setAnim("snap");
      setDx(0);
      setLeftOpen(false);
      crossedRef.current = { left: false, right: false, reveal: false };
      return;
    }
    setDrag(false);

    const abs = Math.abs(dx);
    const wasTap = abs < 6 && !cancelledByScroll.current;

    if (leftOpen && wasTap) {
      commitDownload();
      setAnim("snap"); setDx(0); setLeftOpen(false);
      return;
    }

    if (wasTap) {
      if (isActive) {
        setAnim("snap"); setDx(0);
        onToggle();
      } else {
        emitPlayTrack(t);
        setAnim("snap"); setDx(0);
        onToggle();
      }
      return;
    }

    const commitRemove = () => {
      setAnim("remove");
      hapticImpact("heavy");
      setTimeout(() => {
        removeFromPlaylist(t.id);
        setAnim("snap"); setDx(0); setLeftOpen(false);
        setToast("removed");
      }, 200);
    };

    // коммиты по порогам
    if (dx >= TRIGGER_COMMIT) {
      if (mode === "default") commitAdd();
      else commitDownload();   // playlist: вправо — скачать через бота
      setAnim("snap"); setDx(0); setLeftOpen(false);
      return;
    }
    if (dx <= -TRIGGER_COMMIT) {
      if (mode === "playlist") {
        commitRemove();        // playlist: влево — удалить
        return;
      } else {
        commitDownload();
        setAnim("snap"); setDx(0); setLeftOpen(false);
        return;
      }
    }

    // небольшой левый — фиксируем reveal
    if (dx < 0 && Math.abs(dx) >= LEFT_MIN_OPEN) {
      setAnim("snap"); setDx(-LEFT_REVEAL); setLeftOpen(true);
      return;
    }

    // возврат
    setAnim("snap"); setDx(0); setLeftOpen(false);
  };

  const leftBgColor =
    mode === "playlist"
      ? `rgba(220,38,38,${0.35 + 0.65 * pctLeft})`
      : `rgba(37,99,235,${0.35 + 0.65 * pctLeft})`;
  const rightBgColor =
    mode === "default"
      ? `rgba(132,171,123,${0.35 + 0.65 * pctRight})`
      : `rgba(37,99,235,${0.35 + 0.65 * pctRight})`;

  return (
    <div className="relative">
      {/* ПОДЛОЖКА */}
      {showBg && !scrubbing && (
        <>
          {(dx < 0 || leftOpen) && (
            <div
              className="absolute inset-0 rounded-2xl overflow-hidden select-none flex items-center justify-end pr-4"
              style={{ background: leftBgColor, transition: "background 120ms linear" }}
            >
              <span className="text-white text-sm opacity-90">
                {mode === "playlist" ? "Удалить" : "Скачать"}
              </span>
            </div>
          )}
          {dx > 0 && (
            <div
              className="absolute inset-0 rounded-2xl overflow-hidden select-none flex items-center justify-start pl-4"
              style={{ background: rightBgColor, transition: "background 120ms linear" }}
            >
              <span className="text-white text-sm font-medium">
                {mode === "default" ? (already ? "В плейлисте" : "В плейлист") : "Скачать"}
              </span>
            </div>
          )}
        </>
      )}

      {/* КАРТОЧКА */}
      <div
        ref={cardRef}
        role="button"
        tabIndex={0}
        aria-pressed={playing}
        onPointerDown={onPointerDown}
        onPointerMove={onPointerMove}
        onPointerUp={onPointerUp}
        onPointerCancel={onPointerCancel}
        onTouchMoveCapture={(e) => { if (scrubbing) e.preventDefault(); }}
        onContextMenu={(e) => e.preventDefault()}
        onKeyDown={(e) => {
          if (e.key === "Enter" || e.key === " ") { e.preventDefault(); onToggle(); }
          if (e.key === "Escape" && leftOpen) { setAnim("snap"); setDx(0); setLeftOpen(false); }
        }}
        style={{
          ...style,
          userSelect: "none",
          WebkitUserSelect: "none",
          WebkitTouchCallout: "none",
        }}
        className={
          "z-10 cursor-pointer rounded-2xl p-4 shadow bg-white dark:bg-zinc-900 " +
          "border border-zinc-200 dark:border-zinc-800 overflow-hidden select-none " +
          (isActive ? (isPaused ? "opacity-95" : "") : "hover:bg-white/95 dark:hover:bg-zinc-900/95")
        }
      >
        {/* фон прогресса */}
        <div className="absolute inset-0 z-0 pointer-events-none">
          <GradientBackdropFill
            progress={isActive ? (scrubbing ? scrubPct : lastProgressRef.current) : 0}
            active={!!isActive && !isPaused}
            colors={["#67d4d9", "#5b95f7", "#66daea", "#5db5f7"]}
          />
        </div>

        {/* кольцо */}
        {isActive && (
          <GradientRing
            className="absolute inset-0 z-10"
            radius={16}
            thickness={2}
            colors={["#67d4d9", "#5b95f7", "#66daea", "#5db5f7"]}
            speed={0.6}
            active
          />
        )}

        <div className="flex items-center gap-3">
          <div className="flex-1 min-w-0 pr-2 text-left">
            <div className="text-base font-semibold truncate text-white drop-shadow-[0_1px_2px_rgba(0,0,0,.35)]">
              {t.title}
            </div>
            <div className="text-sm truncate text-zinc-200 drop-shadow-[0_1px_2px_rgba(0,0,0,.35)]">
              {t.artists?.join(", ")}
            </div>
            <div className="mt-1 text-xs truncate text-zinc-300/80 drop-shadow-[0_1px_1px_rgba(0,0,0,.35)]">
              {t.hashtags?.join(" ")}
            </div>
          </div>
        </div>

        {toast && (
          <div
            className={`absolute top-2 right-2 z-20 text-xs rounded-md px-2 py-1
                ${toastBgClass} text-white shadow-sm pointer-events-none`}
          >
            {toast === "added" ? "Добавлено"
              : toast === "exists" ? "Уже в плейлисте"
                : toast === "removed" ? "Удалено"
                  : toast === "sending" ? "Отправляю…"
                    : toast === "sent" ? "Отправлено"
                      : toast === "error" ? "Ошибка отправки"
                        : ""}
          </div>
        )}
      </div>
    </div>
  );
}